# 부분집합
* 집합에 포함된 원소들을 선택하는 것
* 부분집합에는 아무것도 선택하지 않은 경우도 집합에 포함(공집합)

## 집합에서 부분집합을 찾아내는 구현방법
1. 완전탐색
* 재귀 호출을 이용한 완전탐색으로, 부분집합을 구할 수 있음
* 실전보다는 학습용으로 추천
2. Binary Counting
* 2진수 & 비트연산을 이용하여, 부분집합을 구할 수 있음
* 부분집합이 필요할 때 사용하는 추천 방법
  
### 완전탐색으로 부분집합 구하기
ex) 민철이에게 {MIN,CO,TIM} 세명의 친구가 있을 때 함께 영화관에 갈 수 있는 멤버를 구성하는 모든 경우는?<br>
branch =2,level=3 인 tree구조
```py
arr = ['O', 'X']
path = []
name = ['MIN','CO','TIM']

def print_name():
    print('{', end='')
    for i in range(3):
        if path[i]=='0':
            print(name[i],end = ' ')
    print('}')

def run(lev):
    if lev==3:
        print_name()
        return

    for i in range(2):
        path.append(arr[i])
        run(lev+1)
        path.pop()
run(0)
```

## Binary Counting
* 원소 수에 해당하는 N개의 비트열을 이용
* {A,B,C}이라면 비트열에 따른 집합의 표현은 아래와 같음

|10진수|이진수|{A,B,C}|
|---|---|---|
|0|000|{}|
|1|001|{A}|
|2|010|{B}|
|3|011|{A,B}|
|4|100|{C}|
|5|101|{A,C}|
|6|110|{B,C}|
|7|111|{A,B,C}|

* 0b110이 주어지면, BC 출력하는 함수
    * 6(0b110)에서 비트연산을 이용하여 마지막 한자리가 1인지 0인지 검사
```py
arr=['A','B','C']
n=len(arr)

def get_sub(tar):
	for i in range(n):
		# 1비트인지 확인
		if tar & 0x1:
			print(arr[i],end='')
		tar >>=1 # 검사한 한자리를 제거한다.
get_sub(6)
```

* 위를 응용한 부분집합 코드
```py
arr=['A','B','C']
n=len(arr)

def get_sub(tar):
	for i in range(n):
		# 1비트인지 확인
		if tar & 0x1:
			print(arr[i],end='')
		tar >>=1 # 검사한 한자리를 제거한다.

for tar in range(1<<n): # range(0,8)
	print('{', end ='')
	get_sub(tar)
	print('}')
```

### 예시2
* 민철이가 친구 {A,B,C,D,E} 중 2명이상의 친구를 선정하여 함께 카페에 가고 싶을때, 총 경우의 수는?
```py
arr=['A','B','C','D','E']
n=len(arr)

def get_count(tar):
	cnt =0
	for i in range(n):
		# 1비트인지 확인
		if tar & 0x1:
			cnt +=1
			# right shift 비트연산자 -> 오른쪽 끝 비트를 하나씩 제거
		tar >>=1 # 검사한 한자리를 제거한다.
	return cnt

result =0
for tar in range(1<<n): # range(0,32)
	if get_count(tar)>=2: # bit가 2개 이상 1이라면
		result +=1
print(result) # 26
```

# 조합
* 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
* 순열 : 5명 중 1등에서 3등 뽑기 vs 조합 : 5명 중 3명 고르기

## 예시
{A,B,C,D,E} 5명 중 3명 뽑을 수 있는 모든 경우
```py
# 3중 for문으로 구현
arr =['A','B','C','D','E']

for a in range(5):
	start1 = a+1
	for b in range(start1,5):
		star2 =b +1
		for c in range(star2,5):
			print(arr[a],arr[b],arr[c])

# 재귀 호출로 구현
arr =['A','B','C','D','E']
path =[]

n=3
def run(lev,start):
	if lev ==n:
		print(path)
		return
	for i in range(start,5):
		path.append(arr[i])
		run(lev+1,i+1)
		path.pop()
run(0,0)
```
# 비트와 바이트
* 1bit : 0과1을 표현하는 정보의 단위
* 1Byte : 8 bit를 묶어 1 Byte라고 한다.

## 비트 연산
* 컴퓨터의 CPU는 0과 1로 다루어 동작되며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산

### AND 와 OR
* a AND b : a,b 둘다 1일때만 1. 그외는 0
* a OR b : a,b 둘중 하나만 1이면 1. 그외에는 0

* 연산자 & : 비트 단위로 AND 연산을 한다.
* 연산자 | : 비트 단위로 OR 연산을 한다.

* 파이썬에서 2진수, 16진수, 10진수로 변환하여 출력하기
    * 2진수는 숫자 0과 b 인 접두사 0b를 붙여 표현
    * 16진수는 숫자 0과 x 인 접두사 0x를 붙여 표현

    * 파이썬에서는 내장함수로 구현이 가능
    ```py
    print(bin(10))  # 0b1010
    print(hex(10))  # 0xa

    print(int('1011',2)) # 2진수
    print(int('b',16)) # 16진수
    ```

### XOR 연산자
* ^ : XOR 연산자, OR처럼 동작하는데 둘다 1인 경우는 0이다.(같으면 0 다르면 1)
* 임의 수로 2회 XOR 연산을 진행하면 원래 수로 돌아옴.
ex)
7070 ^ 1004 = 6258
6258 ^ 1004 = 7070
* 위의 성질을 이용하여 암호하는데 XOR 연산자를 사용할 수 있음(최근에는 이 방법을 사용하지 않음)
    * 비밀코드를 알고 있고 그 수를 이용하여 암호화와 디코딩이 가능함
```py
Key= 1004
def encode_decode(num):
    return num ^ Key
print (encode_decode(1000)) # 26
print (encode_decode(4)) # 1211

```

### Left와 Right Shift 연산자
* Left Shift << : 특정 수 만큼 비트를 왼쪽으로 밀어낸다 (우측에 0이 생성된다.)
* Right Shift >> : 특정수 만큼 비트를 오른쪽으로 밀어낸다 (우측 비트들이 제거된다.)

#### 비트연산의 응용
* 1 << n
    * 2**n의 값을 갖는다.
    * 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.
* i & (1 << n)
    * i의 n번 비트가 1인지 아닌지를 확인할 수 있다.
    ex) 1101 & (1<<2) : 2번 bit가 1인지 확인 가능하다.

    먼저 (1<<2)를 하면 100이 된다.
    이후 1101 & 0100 = 0100이 되고
    0100은 0보다 큰 수이므로, n번 비트 1임이 확정된다.
    만약 연산 결과가 0이라면, n번 비트는 0임이 확정된다.

* 음수 표현 방법
    * 컴퓨터는 음수를 '2의 보수'로 관리한다.
    맨 앞자리 bit(MSB)는 음수or 양수를 구분하는 비트이다.
    * 5-3을 5+(-3)으로 바꿔 빠르게 연산하기 위해 보수 관리를 한다.
    
    -5 : 11111011
    -4 : 11111100
    -3 : 11111101
    -2 : 11111110
    -1 : 11111111
     0 : 00000000
     1 : 00000001
     2 : 00000010
     3 : 00000011
     4 : 00000100
     5 : 00000101

    * 2의 보수 예시
        * 10001의 2의 보수
            * 수를 모두 뒤집고 +1을 한다.
            * 01110 +1 =01111
        * 11110000의 2의 보수
            * 수를 뒤집으면 0000111이고 +1을 한다.
            * 0000111 +1 = 0001000
        * -5를 2의 보수로 표현하는 방법(가정:8bit로 저장하는 경우)
            * 수 5를 2진수로 나타내면 0000101
            * -5는 음수이므로 MSB는 1
            * 나머지 7bit에 대해 수를 뒤집고 1을 더함(2의보수 처리)
                * 1111010에 1을 더해서 1111011
            * MSB를 더하면 11111011
        
        * 맨 앞자리를 MSB라고 하는데 음수or 양수를 구분하는 비트 0으로 시작하면 양수 1로 시작하면 음수로 정의(c의 경우 unsigned로 부호 비트를 안사용할수 있어서 0~255로 표현하고 signed는 -128~127로 표현) => 1byte에서는 127까지만 저장가능 2byte가 되어야 128을 표현
        * 2의 보수는 2번 취하면 원래의 값으로 돌아온다

* NOT 연산자
    * (~) NOT 연산자 : 모든 비트를 반전시킨다.
    * 만약 8 bit 일때 ~(00011111)면 11100000
    * ~4 = -5가 출력
        * 4 = 0b0100
        * NOT 연산자로 인해 뒤집으면 1011
        * MSB는 1이 되어 음수가 되고 나머지 비트는 011
        * 나머지 bit에 대해 2의 보수를 취하면 100 +1 = 101이므로 5가 되어 -5
    * byte가 정해져있으면 unsigned로 지정시 not을 사용해도 양수에서 not을 붙여도 음수가 안될 수 있지만
        - python은 signed로 수를 관리하기 때문에 not 사용시 음수로 바뀜

# 실수
* 파이썬은 실수 출력 시 f-string 문법을 지향
    * 소수점 출력 시 {t2:.2f} : t2 값을 소수점 둘째자리까지 반올림하여 표현
    ```py
    t1=10
    t2 = 3.141592

    print(f'변수 값은 {t1}입니다') # 변수 값은 10입니다.
    print(f'변수 값은 {t2:.2f} 입니다.') # 변수 값은 3.14입니다.

    ```
* 파이썬의 실수 표현 범위
    * 최대 1.8 *10**308이고 이 이상은 inf로 표현
    * 최소 5.0 * 10**(-324)이고 이 이하는 0으로 표현
* 컴퓨터는 실수를 내부적으로 근사적 관리를 하여 Floating Rounding Error가 발생(math.isclose()로 실수 판별 가능)
    * 실수는 정확한 값이 아닌 근사값으로 저장되면서 작은 오차가 계산에서 생김

    * 근사값으로 저장되는 원리 : 소수점이 있는 10진수를 2진수로 변환하면서 내려감
    0.75 = 2 \*\*-1 + 2\*\*-2 =0b0.11
    0.40625 = 0b0.01101
# 카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 제한 사항
 - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
 - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야함

* 시간 복잡도 O(n+k)
n은 리스트 길이, k는 정수의 최대값

## 카운팅 정렬 과정
- [0,4,1,3,1,2,4,1]을 카운팅 정렬하는 과정
1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다. => counts = [0]* (k+1) ☆☆☆☆
![카운팅 정렬 1](<카운팅정렬 1.PNG>)

counts[x] +=1 => 수도 코드 counts[x]++

for x in data:
counts[x] +=1 (인덱스의 개수에 맞게 count를 설정 해줘야함.)
2. 정렬된 집합에서 각항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
(개수를 누적할 수 있음)
![누적개수구하기](<카운팅정렬 2.PNG>)
원래 배열에 다시 추가해주는 형태로 만들어서 시간을 단축하면서 누적합을 구할 수 있음<br>
수도 코드로 표현하면
```
for i: 1-> k
    counts[i]<- count[i-1]+counts[i]
```
!! 합 - 합으로 구간의 합을 구할 수 있다
ex) 배열에서 4,5,6 번째의 합을 구한다고 가정하면
6번째 누적합 - 3번째 누적합으로 대체 가능

3. 원본 데이터랑 같은 크기의 temp를 만들고 
원본데이터의 맨마지막 숫자를 확인 마지막 숫자가 있는 곳의 누적합의 개수를 확인하고 temp의 해당 위치에 넣어주고 누적합을 1개를 줄임
![카운팅 정렬3](<카운팅정렬 3.PNG>)
사진의 예시를 보면 원본데이터의 마지막은 1이어서 1까지의 누적합은 4이므로 temp의 4번째 위치= 인덱스 3에 1을 넣어주고 누적합은 4에서 3으로 줄여줌
같은 방법으로 앞으로 탐색하면서 temp에 나머지 숫자를 정렬하면 정렬할 수 있음
* 카운팅 정렬의 특징 : 정렬을 시행되면 원본의 순서가 지켜지는 stable 정렬을 함.
![카운팅정렬 마무리](<카운팅정렬 4.PNG>)
count[0]을 감소시키고 temp에 0을 삽입한다.
Temp업데이트 완료하고 정렬 작업을 종료한다.


## 카운팅 정렬 수도코드
![Alt text](<카운팅 정렬 알고리즘.PNG>)

```py
N= 6
K = 9 # 0~k
data = [7,2,4,5,1,3] # 0~9
counts = [0] *(K+1)
temp = [0]*N
# counts 배열에 기록하기
for x in data:
    counts[x] +=1
# counts 누적합 구하기
for i in range(1, K+1):
    counts[i] += counts[i-1]
# data의 마지막 원소부터 정렬하기

for i in range(N-1,-1,-1): # N-1 -> 0의 역순으로
    counts[data[i]] -=1 # 개수를 인덱스로 변환
    temp[counts[data[i]]] = data[i] # temp에 저장될 위치와 마지막 값을 저장
print(*temp) # 1 2 3 4 5 7
```
### 정렬 방법의 시간복잡도 비교
![각 정렬 방법 비교](<정렬방법 비교.PNG>)


# Baby-gin Game
* 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우 triplet이라고 한다.
* 그리고, 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin으로 부른다
* 6자리의 숫자를 입력받아 baby-gin여부를 판단하는 프로그램을 작성하라.
## 입력예시
* 667767은 두 개의 triplet이므로 baby-gin이다.(666,777)
* 054060은 한 개의 run과 한 개의 triplet이므로 역시 baby-gin이다(456,600)
* 101123은 한 개의 triplet가 존재하나, 023이 run이 아니므로 baby-gin이 아니다.(123을 run으로 사용하더라도 011이 run이나 triplet가 아님)

## 완전검색
* 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
* Brute-force 혹은 generate-and-test 기법이라고도 불림
* 모든 경우의 수를 테스트한 후, 최종해법 도출
* 일반적으로 경우의 수가 상대적으로 작을 때 유용
* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 낮다.
* 자격검정평가 등에서 주어진 문제를 풀때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

### 완전 검색을 활용한 baby-gin 접근
* 고려할 수 있는 모든 경우의 수 생성하기(중복 포함)
- 예를들어 [2,3,5,7,7,7]을 받았을 경우, 모든 순열을 생성해보고 그중 앞의 3자리와 뒤의 3자리를 잘라 run과 triplet여부를 테스트

## 그리디 알고리즘
* 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
* 각 선택의 시점에서 이루어진는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
* 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
### 그리디 알고리즘의 동작 과정
1. 해 선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합에 추가
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다.
문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다.
아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

### 그리디 알고리즘 예시
* 어떻게 하면 손님에게 거스름 돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?
1. 해선택 : 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들기 때문에 현재 고를 수 있는 가장 단위 큰 동전을 하나 골라 거스름돈에 추가한다.
2. 실행 가능성 검사 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한단계 작은 단위의 동전을 추가한다.
3. 해검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야 하는 액수와 일치하기 때문에 액수가 모자라다면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다.

하지만 이 때, 400원의 동전이 있다면 이야기가 달라진다. 최적의 해라고 생각한 경우가 최적이 아닐 가능성도 존재

## Baby-gin을 완전 검색이 아닌 방법으로 풀어보기
count배열의 각 원소를 체크하여 판단하기
![수도코드](<baby-gin count배열.PNG>)

```py
num = 456789
c=[0]*12
while num>0: # 자리수별로 카운팅 하기
    c[num%10] +=1
    num //= 10
i = 0
tri= run =0
while i<10:
    if c[i] >= 3: # triplet을 조사 후 데이터 삭제
        c[i] -=3
        tri +=1
        continue
    elif c[i]>=1 and c[i+1]>=1 and c[i+2]>=1: # run을 조사하기 위해 c의 리스트에 마지막에 두개의 더미를 추가함
        c[i] -=1
        c[i+1] -=1
        c[i + 2] -= 1
        run +=1
        continue
    i +=1
if run + tri ==2:
    print ('baby gin')
else:
    print('lose')

```
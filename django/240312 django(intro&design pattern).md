# Web Application
* 인터넷을 통해 사용자에게 제공하는 소프트웨어 프로그램을 구축하는 과정
* 다양한 디바이스(모바일,태블릿,pc 등)에서 웹 브라우저를 통해 접근하고 사용할 수 있음
  
# 클라이언트와 서버
* 웹의 동작 방식

![클라이언트와 서버](<../이미지/240312/클라이언트와 서버.PNG>)

* Client
  * 서비스를 요청하는 주체(웹 사용자의 인터넷이 연결된 장치, 웹 브라우저)
* Server
  * 클라이언트의 요청에 응답하는 주체(웹페이지, 앱을 저장하는 컴퓨터)

* 우리가 웹페이지를 보는 과정
  * 웹 브라우저(클라이언트)에서 'google.com'(주소)을 입력
  * 브라우저는 인터넷에 연결된 전세계 어딘가에 있는 구글 컴퓨터(서버)에게 'google 홈페이지.html' 파일을 달라고 요청
  * 요청을 받은 구글 컴퓨터는 데이터베이스에서 'Google 홈페이지.html'(메인페이지)파일을 찾아 응답
  * 전달받은 'google 홈페이지.html'파일을 사람이 볼 수 있도록 웹 브라우저가 해석해주면서 사용자는 구글의 메인 페이지를 보게됨

![웹을보는과정](<../이미지/240312/웹을 보는과정.PNG>)

# Front-end 와 Back-end
* 웹 개발에서의 Frontend와 Backend
  * Frontend(프론트엔드)
    * 사용자 인터페이스(UI)를 구성하고, 사용자가 애플리케이션과 상호작용할 수 있도록 함
    * HTML, CSS, JavaScript, 프론트엔드 프레임워크등
  * Backend(백엔드)
    * 서버 측에서 동작하며, 클라이언트의 요청에 대한 처리와 데이터 베이스와의 상호작용 등을 담당
    * 서버 언어(Python,Java 등) 및 백엔드 프레임워크, 데이터베이스, API, 보안 등
  
![front back](<../이미지/240312/frontend와 backend.PNG>)

# Framework
## Web Framework
* 웹 서비스 개발
  * 로그인, 로그아웃, 회원관리, 데이터베이스, 보안 등.. 너무 많은 기술들이 필요하기 때문에 개발자가 하나부터 열까지 모두 작성하는 것은 현실적으로 어려움
  * 하지만 모든 걸 직접 만들 필요가 없음
  * 잘 만들어진 것들을 가져와 좋은 환경에서 내것으로 잘 사용하는 것이 능력인 시대
* Web FrameWork
  * 웹 애플리케이션을 빠르게 개발할 수 있도록 도와주는 도구
  (개발에 필요한 기본구조,규칙,라이브러리 등을 제공)

## Django Framework
Python 기반 대표적인 웹 프레임워크
* 장점
  * 다양성 : 소셜미디어 및 빅데이터관리등 광범위한 서비스 개발에 적합
  * 확장성 : 대량의 데이터에 대해 빠르고 유연하게 확장할 수 있는 기능을 제공
  * 보안 : 취약점으로부터 보호하는 보안 기능이 기본적으로 내장되어 있음
  * 커뮤니티 지원 : 개발자를 위한 지원, 문서 및 업데이트를 제공하는 활성화 된 커뮤니티
  
![django기반서비스](<../이미지/240312/django를 활용한 기업.PNG>)

# 가상환경
* python 애플리케이션과 그에 따른 패키지들을 **격리**하여 관리할 수 있는 **독립적인 실행 환경**

## 가상환경이 필요한 시나리오
### 시나리오1
1. 한개발자가 2개의 프로젝트(A와 B)를 진행해야 한다.
2. 프로젝트 A는 requests 패키지 버전1을 사용해야한다.
3. 프로젝트 B는 requests 패키지 버전2을 사용해야한다.
4. 하지만 파이썬 환경에서 패키지는 1개의 버전만 존재할 수 있다.
5. A와 B 프로젝트의 다른 패키지 버전사용을 위한 독립적인 개발 환경이 필요하다.

### 시나리오2
1. 한개발자가 2개의 프로젝트(A와 B)를 진행해야 한다.
2. 프로젝트 A는 water 패키지를 사용해야한다.
3. 프로젝트 B는 fire라는 패키지를 사용해야한다.
4. 하지만 파이썬 환경에서 water와 fire 패키지를 함께 사용하면 충돌이 발생하기 때문에 설치할 수 없다.
5. A와 B 프로젝트의 패키지 충돌을 피하기 위해 각각 독립적인 개발 환경이 필요하다.

![가상환경](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD.PNG)

가상환경을 통해 서로다른 버전을 관리할 수 있음
가상환경은 git에 올리면 안됨(.gitignore를 만들어놓고 시작)

## 가상환경 생성(git bash활용)
가상연결끊기 - deactivate
1. 가상환경 venv 생성(이름을 바꿀수 있지만 하지 않는다 가상환경이라는 약속)
$ python -m venv(가상환경을 만들거라는 명령어) venv(가상환경 이름)

![가상환경 생성2](<../이미지/240312/가상환경 생성1.PNG>)

venv 폴더의 경로를 바꾼다면 가상환경이 고장날 수 있음 이때는 venv폴더를 지우고 새로 생성해주면됨

2. 가상환경 활성화
* 가상환경의 스위치를 온오프해줘서 사용여부를 결정
* 가상환경 내부의 값을 수정하지 말것
* 하나의 가상환경을 켰다고해서 다른 영역의 git bash가 모두 그 가상환경이 켜지는 것이 아님, 다른 창에서는 global상태로 열림
* 위의 말은 여러개의 가상환경을 실행하는 것이 가능하다는 뜻

$ source venv/Scripts/activate

![가상환경 생성2](<../이미지/240312/가상환경 생성2.PNG>)

3. 환경에 설치된 패키지 목록 확인

![가상환경 생성3](<../이미지/240312/가상환경 생성3.PNG>)

* 패키지 목록이 필요한 이유
  * 만약 2명(A와 B)의 개발자가 하나의 프로젝트를 함께 개발한다고 하자.
  * 팀원 A가 먼저 가상 환경을 생성 후 프로젝트를 설정하고 관련된 패키지를 설치하고 개발하다가 협업을 위해 github에 프로젝트를 push한다.
  * 팀원 B는 해당 프로젝트를 clone 받고 실행해보려하지만 실행되지 않음
  * 팀원 A 가 이 프로젝트를 위해 어떤 패키지를 설치했고, 어떤 버전을 설치했는지 A의 가상환경 상황을 알수 없다.
  * 가상환경에 대한 정보 즉 패키지 목록이 공유되어야 한다.

* 의존성 패키지
  * 한 소프트웨어 패키지가 다른 패키지의 기능이나 코드를 사용하기 때문에 그 패키지가 존재해야만 제대로 작동하는 관계
  * 사용하려는 패키지가 설치되지 않았거나, 호환되는 버전이 아니면 오류가 발생하거나 예상치 못한 동작을 보일 수 있음
  
![의존성 패지지 예시](<../이미지/240312/의존성 패키지.PNG>)

4. 의존성 패키지 목록 생성

![의존성 패키지 목록 생성](<../이미지/240312/의존성 패키지 목록 생성.PNG>)

$ pip freeze = 의존성 패키지 목록을 확인

![pip freeze](<../이미지/240312/pip freeze.PNG>)

\> requiremnets.txt == 의존성 패키지 목록을 requirements.txt에 작성하여 저장

![requirements 생성](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/requirements.PNG)

이미 requirements 목록이 형성되어있는경우, 가상환경을 requirements의 환경과 동일하게 패키지를 설치하려면
$ pip install -r requirements.txt 로 입력

* 의존성 패키지 관리의 중요성
  * 개발 환경에서는 각각의 프로젝트가 사용하는 패키지와 그버전을 정확히 관리하는 것이 중요
* 가상 환경&의존성 패키지 관리

* Git ignore 만드는 법
  gitignore.io - django,python,visualStudioCode

# Django 프로젝트
* 프로젝트 생선전 루틴
0. git ignore 생성 = manage.py와 동일한 위치에 만들기

![프로젝트 시작전 루틴](<../이미지/240312/django project 시작전 루틴.PNG>)

* python이 3.10일때 pip install django==4.2로 설치

* 프로젝트 생성
  * 이때 .은 현재 위치를 의미하는데 현재위치에 프로젝트화를 함. '.'을 안사용하면 폴더를 만들고 다시 폴더위치로 이동해야되는 불편함이 있음

  ![프로젝트 생성](<../이미지/240312/django 프로젝트 생성.PNG>)
   ![서버 실행](<../이미지/240312/django project 서버 실행.PNG>)
  ![서버 확인](<../이미지/240312/django project 서버 확인.PNG>)
   
  ![프로젝트 생성 루틴](<../이미지/240312/django project 생성 루틴 + git.PNG>)

# 참고
* LTS(Long-Term Support)
  * Django는 4.2 버전 아직 5. 대 버전은 LTS를 지원하지 않음
  * 프레임워크나 라이브러리 등의 소프트웨어에서 장기간 지원되는 안정적인 버전을 의미할 때 사용
  * 기업이나 대규모 프로젝트에서는 소프트웨어 업그레이드에 많은 비용과 시간이 필요하기 때문에 안정적이고 장기간 지원되는 버전이 필요
  * https://www.djangoproject.com/download/

* Django는 백엔드에 특화되어 있고 front도 지원하지만 제한사항이 많음


# Django Design Pattern
## 디자인 패턴
* 소프트웨어 설계에서 발생하는 문제를 해결하기 위한 일반적인 해결책(공통적인 문제를 해결하는 데 쓰이는 형식화 된 관행)
* '애플리케이션의 구조는 이렇게 구성하자' 라는 관행

## MVC 디자인 패턴(Model, View, Controller)
* 애플리케이션을 구조화 하는 대표적인 패턴
* ('데이터' & '사용자 인터페이스' & '비즈니스 로직'을 분리)
* 시각적 요소와 뒤에서 실행되는 로직을 서로 영향 없이, 독립적이고 쉽게 유지 보수할 수 있는 애플리케이션을 만들기 위해

## MTV 디자인 패턴(Model,Template,View)
* Django에서 애플리케이션을 구조화하는 패턴
* 기존 MVC패턴과 동일하나 단순히 명칭을 다르게 정의한 것
* View == Template
* Controller == View

# Project & App
## Django application
* 독립적으로 작동하는 **기능 단위 모듈**
* 각자 특정한 기능을 담당하며 다른 앱들과 함께 하나의 프로젝트를 구성
* 프로젝트 : 전체설정 담당
* 앱 : DB, 인증, 화면

* 앱을 사용하기 위한 순서
1. 앱 생성
* 앱의 이름은 '복수형으로 지정하는 것을 권장'
![앱생성](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%EC%95%B1%EC%83%9D%EC%84%B1.PNG)

2. 앱 등록
* 반드시 앱을 생성한 후에 등록해야 함
* 등록 후 생성은 불가능
* ,를 반드시 입력해야함
![앱등록](<../이미지/240312/앱 등록.PNG>)


* 프로젝트 구조
![프로젝트구조1](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B5%AC%EC%A1%B01.PNG)
![프로젝트구조2](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B5%AC%EC%A1%B02.PNG)
![프로젝트구조3](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B5%AC%EC%A1%B03.PNG)
![앱구조1](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%EC%95%B1%EA%B5%AC%EC%A1%B01.PNG)
![앱구조2](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/%EC%95%B1%EA%B5%AC%EC%A1%B02.PNG)


# 요청과 응답
![요청과 응답](<../이미지/240312/요청과 응답.PNG>)
View에 화살표가 많은 것처럼 view가 제일 하는 역할이 많음
흐름을 먼저 알고 파일을 수정할 것!

1. URLs
* 사용자가 요청하는 주소와 path를 작성하는 영역  
![URLs](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/URLs.PNG)
![URL 요청](<../이미지/240312/URLs 요청 응답.PNG>)

2. View
모든 view함수는 함수에 받아오는 첫번째 인자(request)가 반드시 필요함. 없으면 view함수가 실행되지 않음
![view](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/view.PNG)

3. Template
![template](../%EC%9D%B4%EB%AF%B8%EC%A7%80/240312/templates.PNG)
![경로 규칙](<../이미지/240312/templates 경로 규칙.PNG>)
![templates](<../이미지/240312/templates 요청 결과.PNG>)

* 중요!
  * 데이터 흐름에 따른 코드 작성하기
  * URLs -> View -> Template
![코드 작성 순서](<../이미지/240312/데이터 흐름에 따른 코드 작성.PNG>)

# 참고
* render 함수
  * html파일을 응답하는 함수
  * 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링 된 텍스트와 함께 HttpResponse 응답 객체를 반환하는 함수
  1. request
   응답을 생성하는 데 사용되는 요청 객체
  2. template name
   템플릿 이름의 경로
  3. context
   템플릿에서 사용할 데이터(딕셔너리 타입으로 작성)

   render(request,template_name,context)
   1,2 필수

## Django 규칙
* urls.py에서 각url 경로는 반드시 '/'로 끝남
* views.py에서 모든 view함수는 첫번째 인자로 요청 객체를 받음
  * 매개 변수 이름은 반드시 request로 지정
* Django는 정해진 경로에 있는 template 파일만 읽어올 수 있음
  * app폴더/templates/이후

## 프레임워크 규칙
* 프레임워크를 사용할 때는 일정한 규칙을 따라야 하며 이는 저마다의 설계 철학이나 목표를 반영하고 있음
  * 일관성 유지, 보안강화, 유지보수성 향상, 최적화 등과 같은 이유
* 프레임워크는 개발자에게 도움을 주는 도구와 환경을 제공하기 위해 규칙을 정해놓은 것이며 우리는 이를 잘 활용하여, 특정기능을 구현 방법을 표준화하고 개발 프로세스를 단순화할 수 있도록 해야함.